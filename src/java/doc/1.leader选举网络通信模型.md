# QuorumCnxManager组件管理节点间网络连接

核心流程：

1. 启动服务端监听线程，等待其他客户端选举完成后，发起向当前节点connect的网络连接
2. 当有其他节点发起网络连接后，读取其sid，跟当前节点比较，如果小于当前节点则关闭socket连接
3. 否则socket连接有效，启动针对该连接的SendWorker发送线程和RecvWorker接收线程
4. 同时初始化针对每个socket连接的ArrayBlockingQueue发送数据队列，长度为1

在QuorumPeer进程启动类启动的时候，会初始化leader选举算法，算法中会初始化QuorumCnxManager组件用于管理server之间的socket连接

```java
@Override
public synchronized void start() {
    //从磁盘加载数据文件到内存
    loadDataBase();

    //启动服务端NIOServerCnxnFactory线程
    cnxnFactory.start();

    //初始化 leader 选举算法
    startLeaderElection();

    //启动QuorumPeer线程
    super.start();
}
```

选举算法的构建流程

```java
synchronized public void startLeaderElection() {
    try {
        //通过 myid、zxid 和 epoch构造当前节点自己的选票
        currentVote = new Vote(myid, getLastLoggedZxid(), getCurrentEpoch());
    } catch(IOException e) {
        RuntimeException re = new RuntimeException(e.getMessage());
        re.setStackTrace(e.getStackTrace());
        throw re;
    }
    //通过配置文件中的myid遍历出当前机器的地址
    for (QuorumServer p : getView().values()) {
        if (p.id == myid) {
            myQuorumAddr = p.addr;
            break;
        }
    }
    if (myQuorumAddr == null) {
        throw new RuntimeException("My id " + myid + " not in the peer list");
    }
    if (electionType == 0) {
        try {
            udpSocket = new DatagramSocket(myQuorumAddr.getPort());
            responder = new ResponderThread();
            responder.start();
        } catch (SocketException e) {
            throw new RuntimeException(e);
        }
    }
    //构造选举算法
    this.electionAlg = createElectionAlgorithm(electionType);
}
```

QuorumCnxManager组件初始化，会启动Listener服务端监听线程，监听其他server发送过来的请求

```java
protected Election createElectionAlgorithm(int electionAlgorithm){
    Election le=null;

    //TODO: use a factory rather than a switch
    switch (electionAlgorithm) {
        case 0:
            le = new LeaderElection(this);
            break;
        case 1:
            le = new AuthFastLeaderElection(this);
            break;
        case 2:
            le = new AuthFastLeaderElection(this, true);
            break;
        case 3:
            //默认用该选举算法
            //构造QuorumCnxManager组件用于管理server之间的tcp连接
            qcm = new QuorumCnxManager(this);
            QuorumCnxManager.Listener listener = qcm.listener;
            if(listener != null){
                //启动Listener线程，用于监听其他server客户端的连接
                listener.start();
                //构建leader选举算法
                le = new FastLeaderElection(this, qcm);
            } else {
                LOG.error("Null listener when initializing cnx manager");
            }
            break;
        default:
            assert false;
    }
    return le;
}
```

## 服务端Listener监听线程

重试机制可以借鉴

```java
/**
 * Thread to listen on some port
 * 每个server都作为ServerSocket来监听其他server作为客户端来连接
 */
public class Listener extends Thread {

    volatile ServerSocket ss = null;

    /**
     * Sleeps on accept().
     */
    @Override
    public void run() {
        int numRetries = 0;
        //重试机制，有异常将ServerSocket关闭再重试
        while((!shutdown) && (numRetries < 3)){
            try {
                ss = new ServerSocket();
                //一个端口释放后会等待两分钟之后才能再被使用，SO_REUSEADDR是让端口释放后立即就可以被再次使用
                ss.setReuseAddress(true);
                //server 之间选举使用的是配置地址中最后的端口号
                int port = self.quorumPeers.get(self.getId()).electionAddr
                    .getPort();
                InetSocketAddress addr = new InetSocketAddress(port);
                LOG.info("My election bind port: " + addr.toString());
                setName(self.quorumPeers.get(self.getId()).electionAddr
                        .toString());
                ss.bind(addr);
                //循环监听指定端口号，有客户端连接则进行后续处理
                while (!shutdown) {
                    Socket client = ss.accept();
                    //设置客户端 Socket 的 NoDelay 和超时时间
                    setSockOpts(client);
                    LOG.info("Received connection request "
                             + client.getRemoteSocketAddress());
                    //处理客户端连接
                    receiveConnection(client);
                    numRetries = 0;
                }
            } catch (IOException e) {
                LOG.error("Exception while listening", e);
                numRetries++;
                try {
                    ss.close();
                    Thread.sleep(1000);
                } catch (IOException ie) {
                    LOG.error("Error closing server socket", ie);
                } catch (InterruptedException ie) {
                    LOG.error("Interrupted while sleeping. " +
                              "Ignoring exception", ie);
                }
            }
        }
        LOG.info("Leaving listener");
        if (!shutdown) {
            LOG.error("As I'm leaving the listener thread, "
                      + "I won't be able to participate in leader "
                      + "election any longer: "
                      + self.quorumPeers.get(self.getId()).electionAddr);
        }
    }

    /**
     * Halts this listener thread.
     */
    void halt(){
        try{
            LOG.debug("Trying to close listener: " + ss);
            if(ss != null) {
                LOG.debug("Closing listener: " + self.getId());
                ss.close();
            }
        } catch (IOException e){
            LOG.warn("Exception when shutting down listener: " + e);
        }
    }
}
```

设置socket参数

```java
private void setSockOpts(Socket sock) throws SocketException {
    //关闭NoDelay算法，数据只有在写缓存中累积到一定量之后，才会被发送出去，这样明显提高了网络利用率，但是不可避免地增加了延时
    sock.setTcpNoDelay(true);
    //设置read超时时间
    sock.setSoTimeout(self.tickTime * self.syncLimit);
}
```

## 为每个有效socket连接创建读写线程

当接收到其他节点发起的connect连接后，交给receiveConnection方法处理

```java
/**
 * If this server receives a connection request, then it gives up on the new
 * connection if it wins. Notice that it checks whether it has a connection
 * to this server already or not. If it does, then it sends the smallest
 * possible long value to lose the challenge.
 *
 * 每个 server 都会有 Listerer 来监听其他 server 作为客户端发起连接的创建
 * server节点之间的socket通信，需要避免建立双向的连接，浪费资源
 * 定义规则：
 * 只能向比自己myid要小的server发起connect连接
 * 服务端节点接受比自己myid要大的连接请求才是有效连接
 *
 */
public boolean receiveConnection(Socket sock) {
    Long sid = null;
    
    try {
        // Read server id
        //其他节点发起连接，如果连接成功创建则会发送属于自己的myid，作为服务端节点这里直接读取
        DataInputStream din = new DataInputStream(sock.getInputStream());
        sid = din.readLong();
        if (sid == QuorumPeer.OBSERVER_ID) {
            /*
             * Choose identifier at random. We need a value to identify
             * the connection.
             */
            
            sid = observerCounter--;
            LOG.info("Setting arbitrary identifier to observer: " + sid);
        }
    } catch (IOException e) {
        closeSocket(sock);
        LOG.warn("Exception reading or writing challenge: " + e.toString());
        return false;
    }
    
    //If wins the challenge, then close the new connection.
    //如果客户端server的myid小于当前server的myid，则关闭该socket连接
    if (sid < self.getId()) {
        /*
         * This replica might still believe that the connection to sid is
         * up, so we have to shut down the workers before trying to open a
         * new connection.
         */
        SendWorker sw = senderWorkerMap.get(sid);
        if (sw != null) {
            //释放资源
            sw.finish();
        }

        /*
         * Now we start a new connection
         */
        LOG.debug("Create new connection to server: " + sid);
        //关闭socket连接
        closeSocket(sock);
        //关闭连接后，主动发起connect连接，因为当前myid一定是大于客户端节点的myid
        connectOne(sid);

        // Otherwise start worker threads to receive data.
    } else {
        //如果客户端server的myid大于当前server的myid，则表示该socket连接是有效的
        //对该连接启动接受与发送线程来进行后续网络数据的通信
        SendWorker sw = new SendWorker(sock, sid);
        RecvWorker rw = new RecvWorker(sock, sid, sw);
        sw.setRecv(rw);

        SendWorker vsw = senderWorkerMap.get(sid);
        
        if(vsw != null)
            vsw.finish();
        
        //全局持有
        senderWorkerMap.put(sid, sw);
        
        //每个server对应的发送队列,队列为有界可阻塞容量为1
        if (!queueSendMap.containsKey(sid)) {
            queueSendMap.put(sid, new ArrayBlockingQueue<ByteBuffer>(
                    SEND_CAPACITY));
        }
        
        //启动读写线程
        sw.start();
        rw.start();
        
        return true;    
    }
    return false;
}
```

# 对socket的发送数据线程SendWorker

核心流程：

1. 每个SendWorker线程用来负责对一个socket进行网络处理，基于socket的OutputStream封装为DataOutputStream流进行数据通信
2. 线程循环不停地从ArrayBlockingQueue待发送队列中获取数据，然后通过socket发送出去
3. 数据发送的网络协议，先发送4个字节长度（Integer类型）的数据长度，再发送真实的数据字节
4. write完后，执行flush()，这里DataOutputStream封装的基于socket的输出流好像没有实现flush，是否可以不调用？

SendWorker本身就是线程，用来将发送队列的数据发送给对应的server端，初始化流程如下

```java
class SendWorker extends Thread {
    Long sid;
    Socket sock;
    RecvWorker recvWorker;
    volatile boolean running = true;
    DataOutputStream dout;

    /**
     * An instance of this thread receives messages to send
     * through a queue and sends them to the server sid.
     * 
     * @param sock
     *            Socket to remote peer
     * @param sid
     *            Server identifier of remote peer
     */
    SendWorker(Socket sock, Long sid) {
        super("SendWorker:" + sid);
        this.sid = sid;
        this.sock = sock;
        recvWorker = null;
        try {
            //封装基于socket的输出流
            dout = new DataOutputStream(sock.getOutputStream());
        } catch (IOException e) {
            LOG.error("Unable to access socket output stream", e);
            closeSocket(sock);
            running = false;
        }
        LOG.debug("Address of remote peer: " + this.sid);
    }
    ...
}   
```

线程执行方法，不停地从queueSendMap对应队列中获取需要发送的数据，通过socket发送出去

```java
@Override
public void run() {
    threadCnt.incrementAndGet();
    try {
        /**
         * If there is nothing in the queue to send, then we
         * send the lastMessage to ensure that the last message
         * was received by the peer. The message could be dropped
         * in case self or the peer shutdown their connection
         * (and exit the thread) prior to reading/processing
         * the last message. Duplicate messages are handled correctly
         * by the peer.
         *
         * If the send queue is non-empty, then we have a recent
         * message than that stored in lastMessage. To avoid sending
         * stale message, we should send the message in the send queue.
         */
        ArrayBlockingQueue<ByteBuffer> bq = queueSendMap.get(sid);
        //如果队列中没有数据需要发送，则发送上一次的消息数据
        if (bq == null || isSendQueueEmpty(bq)) {
           ByteBuffer b = lastMessageSent.get(sid);
           if (b != null) {
               LOG.debug("Attempting to send lastMessage to sid=" + sid);
               send(b);
           }
        }
    } catch (IOException e) {
        LOG.error("Failed to send last message. Shutting down thread.", e);
        this.finish();
    }
    
    try {
        while (running && !shutdown && sock != null) {

            ByteBuffer b = null;
            try {
                ArrayBlockingQueue<ByteBuffer> bq = queueSendMap
                        .get(sid);
                if (bq != null) {
                    //从需要发送消息的队列中阻塞获取数据
                    b = pollSendQueue(bq, 1000, TimeUnit.MILLISECONDS);
                } else {
                    LOG.error("No queue of incoming messages for " +
                              "server " + sid);
                    break;
                }

                if(b != null){
                    //将最近发送的消息保存到SendWorker线程发送消息中
                    lastMessageSent.put(sid, b);
                    //将消息进行发送
                    send(b);
                }
            } catch (InterruptedException e) {
                LOG.warn("Interrupted while waiting for message on queue",
                        e);
            }
        }
    } catch (Exception e) {
        LOG.warn("Exception when using channel: for id " + sid + " my id = " + 
                self.getId() + " error = " + e);
    }
    this.finish();
    LOG.warn("Send worker leaving thread");
}
```

最终的数据通过底层socket输出流发送出去。先发送数据的长度，再发送具体的数据即可

```java
synchronized void send(ByteBuffer b) throws IOException {
    byte[] msgBytes = new byte[b.capacity()];
    try {
        b.position(0);
        //从b中读取所有数据到字节数组msgBytes
        //并且字节数组msgBytes就是b底层持有的字节数组，供后续通过array()获取
        b.get(msgBytes);
    } catch (BufferUnderflowException be) {
        LOG.error("BufferUnderflowException ", be);
        return;
    }
    //也是先发送数据长度
    dout.writeInt(b.capacity());
    //再发送数据字节
    dout.write(b.array());
    dout.flush();
}
```
# 对socket的接收数据线程RecvWorker

核心流程：

1. 每个RecvWorker线程用来负责对一个socket进行网络处理，基于socket的InputStream封装为DataInputStream流进行数据通信
2. 将socket的SoTimeout设置为0，read永不超时，一直去读取socket数据
3. 读取到的数据会放入到全局维护的一个ArrayBlockingQueue有界队列中，这里和SendWorker每个都持有自己的发送队列不同
4. 基于底层输入流读取数据的时候，也是先读取数据长度，再读取具体大小的字节数据

RecvWorker用于接受其他节点发送过来的数据，初始化流程如下

```java
/**
 * Thread to receive messages. Instance waits on a socket read. If the
 * channel breaks, then removes itself from the pool of receivers.
 * 从 socket 中读取消息数据
 */
class RecvWorker extends Thread {
    Long sid;
    Socket sock;
    volatile boolean running = true;
    DataInputStream din;
    final SendWorker sw;

    RecvWorker(Socket sock, Long sid, SendWorker sw) {
        super("RecvWorker:" + sid);
        this.sid = sid;
        this.sock = sock;
        this.sw = sw;
        try {
            //封装针对socket的输入流
            din = new DataInputStream(sock.getInputStream());
            // OK to wait until socket disconnects while reading.
            //读取数据设置为不超时
            sock.setSoTimeout(0);
        } catch (IOException e) {
            LOG.error("Error while accessing socket for " + sid, e);
            closeSocket(sock);
            running = false;
        }
    }
    ...
}   
```

线程执行方法，不停地从socket读取数据，没有数据时也不会超时退出，网络传输协议与写入时一致，读出消息放入到全局的recvQueue队列（ArrayBlockingQueue默认长度为100）

```java
@Override
public void run() {
    threadCnt.incrementAndGet();
    try {
        while (running && !shutdown && sock != null) {
            /**
             * Reads the first int to determine the length of the
             * message
             */
            int length = din.readInt();
            //消息大小的限制
            if (length <= 0 || length > PACKETMAXSIZE) {
                throw new IOException(
                        "Received packet with invalid packet: "
                                + length);
            }
            /**
             * Allocates a new ByteBuffer to receive the message
             */
            //分配指定大小ByteBuffer接收消息
            byte[] msgArray = new byte[length];
            din.readFully(msgArray, 0, length);
            ByteBuffer message = ByteBuffer.wrap(msgArray);
            //读取到的数据放入全局的队列中
            addToRecvQueue(new Message(message.duplicate(), sid));
        }
    } catch (Exception e) {
        LOG.warn("Connection broken for id " + sid + ", my id = " + 
                self.getId() + ", error = " , e);
    } finally {
        LOG.warn("Interrupting SendWorker");
        sw.finish();
        if (sock != null) {
            closeSocket(sock);
        }
    }
}
```

依赖于jdk底层的流处理的粘包与拆包问题

```java
public final void readFully(byte b[], int off, int len) throws IOException {
    if (len < 0)
        throw new IndexOutOfBoundsException();
    int n = 0;
    while (n < len) {
        int count = in.read(b, off + n, len - n);
        if (count < 0)
            throw new EOFException();
        n += count;
    }
}
```

读取到的数据加入接收数据队列中，队列初始长度是100，如果队列满了，删除队头后再加入，节点间的投票数据一般也不会太多

```java
public void addToRecvQueue(Message msg) {
    synchronized(recvQLock) {
        //如果队列满了，从队头移除元素再插入数据
        if (recvQueue.remainingCapacity() == 0) {
            try {
                recvQueue.remove();
            } catch (NoSuchElementException ne) {
                // element could be removed by poll()
                 LOG.debug("Trying to remove from an empty " +
                     "recvQueue. Ignoring exception " + ne);
            }
        }
        try {
            recvQueue.add(msg);
        } catch (IllegalStateException ie) {
            // This should never happen
            LOG.error("Unable to insert element in the recvQueue " + ie);
        }
    }
}
```
# server节点间发送网络数据方法

调用QuorumCnxManager的send方法可以对指定的socket节点发送数据，需要发送的数据加入对应socket连接的发送队列即可

```java
public void toSend(Long sid, ByteBuffer b) {
    /*
     * If sending message to myself, then simply enqueue it (loopback).
     */
    //如果发送给当前节点本身，则直接构造响应加入到响应队列
    if (self.getId() == sid) {
         b.position(0);
         addToRecvQueue(new Message(b.duplicate(), sid));
        /*
         * Otherwise send to the corresponding thread to send.
         */
    } else {
         /*
          * Start a new connection if doesn't have one already.
          */
         if (!queueSendMap.containsKey(sid)) {
             //发送队列容量为1
             ArrayBlockingQueue<ByteBuffer> bq = new ArrayBlockingQueue<ByteBuffer>(
                     SEND_CAPACITY);
             //给指定myid初始化队列
             queueSendMap.put(sid, bq);
             addToSendQueue(bq, b);

         } else {
             ArrayBlockingQueue<ByteBuffer> bq = queueSendMap.get(sid);
             if(bq != null){
                 addToSendQueue(bq, b);
             } else {
                 LOG.error("No queue for server " + sid);
             }
         }
         //发送数据给其他节点时，如果连接不存在，则创建网络连接
         connectOne(sid);
            
    }
}
```

```java
/**
 * Inserts an element in the specified queue. If the Queue is full, this
 * method removes an element from the head of the Queue and then inserts
 * the element at the tail. It can happen that the an element is removed
 * by another thread in {@link SendWorker#processMessage() processMessage}
 * method before this method attempts to remove an element from the queue.
 * This will cause {@link ArrayBlockingQueue#remove() remove} to throw an
 * exception, which is safe to ignore.
 *
 * Unlike {@link #addToRecvQueue(Message) addToRecvQueue} this method does
 * not need to be synchronized since there is only one thread that inserts
 * an element in the queue and another thread that reads from the queue.
 *
 * @param queue
 *          Reference to the Queue
 * @param buffer
 *          Reference to the buffer to be inserted in the queue
 * 如果队列满，删除队头元素再加入队列中
 */
private void addToSendQueue(ArrayBlockingQueue<ByteBuffer> queue,
      ByteBuffer buffer) {
    if (queue.remainingCapacity() == 0) {
        try {
            queue.remove();
        } catch (NoSuchElementException ne) {
            // element could be removed by poll()
            LOG.debug("Trying to remove from an empty " +
                    "Queue. Ignoring exception " + ne);
        }
    }
    try {
        queue.add(buffer);
    } catch (IllegalStateException ie) {
        // This should never happen
        LOG.error("Unable to insert an element in the queue " + ie);
    }
}
```

# server节点主动发起connect连接

发起网络连接的时机：
1. 在发送消息的时候，如果还没有创建与该节点的连接，则发送主动connect网络连接，并且连接一旦创建成功就发送当前节点myid
2. 作为服务端节点接收到比自己myid要小的节点发起的连接创建，则关闭连接后主动发起connect网络连接
3. 节点间投票结束，follower节点会向leader发起connect连接

```java
/**
 * Try to establish a connection to server with id sid.
 * 
 *  @param sid  server id
 */

synchronized void connectOne(long sid){
    //连接不存在才创建新的socket连接
    if (senderWorkerMap.get(sid) == null){
        InetSocketAddress electionAddr;
        //从配置文件中获取server的地址
        if (self.quorumPeers.containsKey(sid)) {
            electionAddr = self.quorumPeers.get(sid).electionAddr;
        } else {
            LOG.warn("Invalid server id: " + sid);
            return;
        }
        try {

            if (LOG.isDebugEnabled()) {
                LOG.debug("Opening channel to server " + sid);
            }
            Socket sock = new Socket();
            setSockOpts(sock);
            //向服务端server创建连接
            sock.connect(self.getView().get(sid).electionAddr, cnxTO);
            if (LOG.isDebugEnabled()) {
                LOG.debug("Connected to server " + sid);
            }
            //初始化连接操作，并保存socket连接
            initiateConnection(sock, sid);
        } catch (UnresolvedAddressException e) {
            // Sun doesn't include the address that causes this
            // exception to be thrown, also UAE cannot be wrapped cleanly
            // so we log the exception in order to capture this critical
            // detail.
            LOG.warn("Cannot open channel to " + sid
                    + " at election address " + electionAddr, e);
            throw e;
        } catch (IOException e) {
            LOG.warn("Cannot open channel to " + sid
                    + " at election address " + electionAddr,
                    e);
        }
    } else {
        LOG.debug("There is a connection already for server " + sid);
    }
}
```

连接创建后，进行对连接的初始化

```java
/**
 * If this server has initiated the connection, then it gives up on the
 * connection if it loses challenge. Otherwise, it keeps the connection.
 *
 * 只能主动向比自己myid要小的节点发起连接的创建请求，否则关闭该连接避免连接的浪费
 */
public boolean initiateConnection(Socket sock, Long sid) {
    DataOutputStream dout = null;
    try {
        // Sending id and challenge
        //作为客户端向服务端创建连接后，发送本身的myid
        dout = new DataOutputStream(sock.getOutputStream());
        dout.writeLong(self.getId());
        dout.flush();
    } catch (IOException e) {
        LOG.warn("Ignoring exception reading or writing challenge: ", e);
        closeSocket(sock);
        return false;
    }

    //如果对方节点myid大于当前节点的myid，则直接断开连接
    // If lost the challenge, then drop the new connection
    if (sid > self.getId()) {
        LOG.info("Have smaller server identifier, so dropping the " +
                 "connection: (" + sid + ", " + self.getId() + ")");
        closeSocket(sock);
        // Otherwise proceed with the connection
    } else {
        //初始化发送与接收消息的线程
        //作为服务端监听到请求后，处理逻辑一致
        SendWorker sw = new SendWorker(sock, sid);
        RecvWorker rw = new RecvWorker(sock, sid, sw);
        sw.setRecv(rw);

        SendWorker vsw = senderWorkerMap.get(sid);
        
        if(vsw != null)
            vsw.finish();
        
        senderWorkerMap.put(sid, sw);
        if (!queueSendMap.containsKey(sid)) {
            queueSendMap.put(sid, new ArrayBlockingQueue<ByteBuffer>(
                    SEND_CAPACITY));
        }

        //启动线程
        sw.start();
        rw.start();
        
        return true;    
        
    }
    return false;
}
```

# 流程图

![leader与follower间选举网络模型](D:\user\文档\cl\doc\zk\1.leader选举网络通信模型.assets\leader与follower间选举网络模型.jpg)