# ZKDatabase组件

在启动zk进程时，会初始化内存数据库ZKDatabase组件

```java
public void runFromConfig(QuorumPeerConfig config) throws IOException {
    try {
        ManagedUtil.registerLog4jMBeans();
    } catch (JMException e) {
        LOG.warn("Unable to register log4j JMX control", e);
    }

    LOG.info("Starting quorum peer");
    try {
        //默认创建的是NIOServerCnxnFactory用来接收客户端的连接
        ServerCnxnFactory cnxnFactory = ServerCnxnFactory.createFactory();
        //配置server监听的ip与端口号，默认2181
        cnxnFactory.configure(config.getClientPortAddress(),
                              config.getMaxClientCnxns());

        //QuorumPeer投票组件线程
        quorumPeer = new QuorumPeer();
        quorumPeer.setClientPortAddress(config.getClientPortAddress());
        //管理磁盘文件数据，用于启动时恢复日志数据
        //初始化事物数据目录组件和快照目录组件
        quorumPeer.setTxnFactory(new FileTxnSnapLog(
            new File(config.getDataLogDir()),
            new File(config.getDataDir())));
        quorumPeer.setQuorumPeers(config.getServers());
        quorumPeer.setElectionType(config.getElectionAlg());
        quorumPeer.setMyid(config.getServerId());
        quorumPeer.setTickTime(config.getTickTime());
        quorumPeer.setMinSessionTimeout(config.getMinSessionTimeout());
        quorumPeer.setMaxSessionTimeout(config.getMaxSessionTimeout());
        quorumPeer.setInitLimit(config.getInitLimit());
        quorumPeer.setSyncLimit(config.getSyncLimit());
        quorumPeer.setQuorumVerifier(config.getQuorumVerifier());
        quorumPeer.setCnxnFactory(cnxnFactory);
        //初始化内存数据库
        quorumPeer.setZKDatabase(new ZKDatabase(quorumPeer.getTxnFactory()));
        quorumPeer.setLearnerType(config.getPeerType());

        //启动线程
        quorumPeer.start();
        quorumPeer.join();
    } catch (InterruptedException e) {
        // warn, but generally this is ok
        LOG.warn("Quorum Peer interrupted", e);
    }
}
```

```java
public ZKDatabase(FileTxnSnapLog snapLog) {
    dataTree = new DataTree();
    sessionsWithTimeouts = new ConcurrentHashMap<Long, Integer>();
    this.snapLog = snapLog;
}
```

ZKDatabase表示内存数据库

```java
/**
 * This class maintains the in memory database of zookeeper
 * server states that includes the sessions, datatree and the
 * committed logs. It is booted up  after reading the logs
 * and snapshots from the disk.
 *
 * 内存数据库，包括session数据、内存元数据、事物日志
 * 可以启动的时候从磁盘读取日志和快照文件
 */
public class ZKDatabase {
    
    private static final Logger LOG = LoggerFactory.getLogger(ZKDatabase.class);
    
    /**
     * make sure on a clear you take care of 
     * all these members.
     */
    //内存数据库，存放树形数据结构
    protected DataTree dataTree;
    protected ConcurrentHashMap<Long, Integer> sessionsWithTimeouts;
    //事物日志、快照文件处理组件
    protected FileTxnSnapLog snapLog;
    protected long minCommittedLog, maxCommittedLog;
    public static final int commitLogCount = 500;
    protected static int commitLogBuffer = 700;
    protected LinkedList<Proposal> committedLog = new LinkedList<Proposal>();
    protected ReentrantReadWriteLock logLock = new ReentrantReadWriteLock();
    volatile private boolean initialized = false;
    ...
}
```

# DataTree内存树形数据结构组件

```java
public class DataTree {
    private static final Logger LOG = LoggerFactory.getLogger(DataTree.class);

    /**
     * This hashtable provides a fast lookup to the datanodes. The tree is the
     * source of truth and is where all the locking occurs
     */
    //根据path快速查询节点
    private final ConcurrentHashMap<String, DataNode> nodes =
        new ConcurrentHashMap<String, DataNode>();

    //监听（Watch）节点数据变化
    private final WatchManager dataWatches = new WatchManager();

    //监听子节点变化
    private final WatchManager childWatches = new WatchManager();

    /** the root of zookeeper tree */
    private static final String rootZookeeper = "/";

    /** the zookeeper nodes that acts as the management and status node **/
    private static final String procZookeeper = Quotas.procZookeeper;

    /** this will be the string thats stored as a child of root */
    private static final String procChildZookeeper = procZookeeper.substring(1);

    /**
     * the zookeeper quota node that acts as the quota management node for
     * zookeeper
     */
    private static final String quotaZookeeper = Quotas.quotaZookeeper;

    /** this will be the string thats stored as a child of /zookeeper */
    private static final String quotaChildZookeeper = quotaZookeeper
            .substring(procZookeeper.length() + 1);

    /**
     * the path trie that keeps track fo the quota nodes in this datatree
     */
    private final PathTrie pTrie = new PathTrie();

    /**
     * This hashtable lists the paths of the ephemeral nodes of a session.
     */
    //维护一个sessionId对应的多个临时节点
    private final Map<Long, HashSet<String>> ephemerals =
        new ConcurrentHashMap<Long, HashSet<String>>();
    ...
}
```

# DataNode数据节点

```java
public class DataNode implements Record {
    /** the parent of this datanode */
    DataNode parent;

    /** the data for this datanode */
    byte data[];

    /**
     * the acl map long for this datanode. the datatree has the map
     */
    Long acl;

    /**
     * the stat for this node that is persisted to disk.
     */
    public StatPersisted stat;

    /**
     * the list of children for this node. note that the list of children string
     * does not contain the parent path -- just the last part of the path. This
     * should be synchronized on except deserializing (for speed up issues).
     */
    private Set<String> children = null;

    /**
     * default constructor for the datanode
     */
    DataNode() {
        // default constructor
    }
    ...
}
```



# FileTxnSnapLog处理事物和快照文件组件

```java
public class FileTxnSnapLog {
    //the direcotry containing the 
    //the transaction logs
    //事物日志目录
    private final File dataDir;
    //the directory containing the
    //the snapshot directory
    //快照文件目录
    private final File snapDir;
    //事物日志组件
    private TxnLog txnLog;
    //快照文件组件
    private SnapShot snapLog;
    public final static int VERSION = 2;
    public final static String version = "version-";
    ...
}
```

# 从磁盘加载数据恢复内存数据库

在zk进程启动的时候会从磁盘加载数据到内存数据库

```java
@Override
public synchronized void start() {
    //从磁盘加载数据文件到内存
    loadDataBase();

    //启动服务端NIOServerCnxnFactory线程
    cnxnFactory.start();

    //初始化 leader 选举算法
    startLeaderElection();

    //启动QuorumPeer线程
    super.start();
}
```

从磁盘加载数据

```java
public long loadDataBase() throws IOException {
    PlayBackListener listener=new PlayBackListener(){
        //用来快速给Follower同步
        public void onTxnLoaded(TxnHeader hdr,Record txn){
            Request r = new Request(null, 0, hdr.getCxid(),hdr.getType(),
                    null, null);
            r.txn = txn;
            r.hdr = hdr;
            r.zxid = hdr.getZxid();
            addCommittedProposal(r);
        }
    };

    //从磁盘加载数据到内存中
    long zxid = snapLog.restore(dataTree,sessionsWithTimeouts,listener);
    initialized = true;
    return zxid;
}
```

从磁盘加载最近的快照文件，然后从事物日志文件中加载快照之后的zxid的数据，恢复到内存数据库中

```java
public long restore(DataTree dt, Map<Long, Integer> sessions, 
                    PlayBackListener listener) throws IOException {
    //从最近的快照中对数据树进行反序列化
    snapLog.deserialize(dt, sessions);
    //事物日志文件目录
    FileTxnLog txnLog = new FileTxnLog(dataDir);
    //快照文件并不是全量的数据，需要从快照加载的最新zxid开始，从事物日志加载后续的数据来组成完成的数据
    //从事物日志中定位出需要开始读取的zxid位置
    TxnIterator itr = txnLog.read(dt.lastProcessedZxid+1);
    long highestZxid = dt.lastProcessedZxid;
    TxnHeader hdr;
    while (true) {
        // iterator points to 
        // the first valid txn when initialized
        hdr = itr.getHeader();
        if (hdr == null) {
            //empty logs 
            return dt.lastProcessedZxid;
        }
        if (hdr.getZxid() < highestZxid && highestZxid != 0) {
            LOG.error(highestZxid + "(higestZxid) > "
                      + hdr.getZxid() + "(next log) for type "
                      + hdr.getType());
        } else {
            highestZxid = hdr.getZxid();
        }
        try {
            //把事务操作在内存中再执行一遍把丢失的操作补回来
            processTransaction(hdr,dt,sessions, itr.getTxn());
        } catch(KeeperException.NoNodeException e) {
            throw new IOException("Failed to process transaction type: " +
                                  hdr.getType() + " error: " + e.getMessage(), e);
        }
        //同时将事务操作通过PlayBackListener添加到commitedLog集合，commitedLog的事务操作在服务恢复的时候会同步到其他leaner server, 因为很有可能其他leaner server也没有及时的takesnapshot
        listener.onTxnLoaded(hdr, itr.getTxn());
        if (!itr.next()) 
            break;
    }
    //最终返回恢复内存数据库的最大zxid
    return highestZxid;
}
```

