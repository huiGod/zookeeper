# FastLeaderElection：选举算法核心

- 外部投票：特指其他服务器发来的投票。
- 内部投票：服务器自身当前的投票。
- 选举轮次：Zookeeper服务器Leader选举的轮次，即logicalclock。
- PK：对内部投票和外部投票进行对比来确定是否需要变更内部投票。

# 选票管理

- sendqueue：选票发送队列，用于保存待发送的选票
- recvqueue：选票接收队列，用于保存接收到的外部投票
- WorkerReceiver：选票接收器。其会不断地从QuorumCnxManager中获取其他服务器发来的选举消息，并将其转换成一个选票，然后保存到recvqueue中，在选票接收过程中，如果发现该外部选票的选举轮次小于当前服务器的，那么忽略该外部投票，同时立即发送自己的内部投票
- WorkerSender：选票发送器，不断地从sendqueue中获取待发送的选票，并将其传递到底层QuorumCnxManager中

# 算法核心

选举流程

​	![1](D:\user\文档\cl\doc\zk\2.leader选举算法详解.assets\1.png)

1. 自增选举轮次。Zookeeper规定所有有效的投票都必须在同一轮次中，在开始新一轮投票时，会首先对logicalclock进行自增操作。
2. 初始化选票。在开始进行新一轮投票之前，每个服务器都会初始化自身的选票，并且在初始化阶段，每台服务器都会将自己推举为Leader。

3. 发送初始化选票。完成选票的初始化后，服务器就会发起第一次投票。Zookeeper会将刚刚初始化好的选票放入sendqueue中，由发送器WorkerSender负责发送出去。

4. 接收外部投票。每台服务器会不断地从recvqueue队列中获取外部选票。如果服务器发现无法获取到任何外部投票，那么就会立即确认自己是否和集群中其他服务器保持着有效的连接，如果没有连接，则马上建立连接，如果已经建立了连接，则再次发送自己当前的内部投票。

5. 判断选举轮次。在发送完初始化选票之后，接着开始处理外部投票。在处理外部投票时，会根据选举轮次来进行不同的处理。

　　　　· 外部投票的选举轮次大于内部投票。若服务器自身的选举轮次落后于该外部投票对应服务器的选举轮次，那么就会立即更新自己的选举轮次(logicalclock)，并且清空所有已经收到的投票，然后使用初始化的投票来进行PK以确定是否变更内部投票。最终再将内部投票发送出去。

　　　　· 外部投票的选举轮次小于内部投票。若服务器接收的外选票的选举轮次落后于自身的选举轮次，那么Zookeeper就会直接忽略该外部投票，不做任何处理，并返回步骤4。

　　　　· 外部投票的选举轮次等于内部投票。此时可以开始进行选票PK。

6. 选票PK。在进行选票PK时，符合任意一个条件就需要变更投票。

　　　　· 若外部投票中推举的Leader服务器的选举轮次大于内部投票，那么需要变更投票。

　　　　· 若选举轮次一致，那么就对比两者的ZXID，若外部投票的ZXID大，那么需要变更投票。

　　　　· 若两者的ZXID一致，那么就对比两者的SID，若外部投票的SID大，那么就需要变更投票。

7. 变更投票。经过PK后，若确定了外部投票优于内部投票，那么就变更投票，即使用外部投票的选票信息来覆盖内部投票，变更完成后，再次将这个变更后的内部投票发送出去。

8. 选票归档。无论是否变更了投票，都会将刚刚收到的那份外部投票放入选票集合recvset中进行归档（有效的选票才归档，也就是版本号大于等于当前节点）。recvset用于记录当前服务器在本轮次的Leader选举中收到的所有外部投票（按照服务队的SID区别，如{(1, vote1), (2, vote2)...}）。

9. 统计投票。完成选票归档后，就可以开始统计投票，统计投票是为了统计集群中是否已经有过半的服务器认可了当前的内部投票，如果确定已经有过半服务器认可了该投票，则终止投票。否则返回步骤4。

10. 更新服务器状态。若已经确定可以终止投票，那么就开始更新服务器状态，服务器首选判断当前被过半服务器认可的投票所对应的Leader服务器是否是自己，若是自己，则将自己的服务器状态更新为LEADING，若不是，则根据具体情况来确定自己是FOLLOWING或是OBSERVING。

以上10个步骤就是FastLeaderElection的核心，其中步骤4-9会经过几轮循环，直到有Leader选举产生

# 源码分析

## 初始化FastLeaderElection投票算法

在节点之间建立好网络连接后，会初始化投票算法FastLeaderElection，进行投票选出leader

```java
protected Election createElectionAlgorithm(int electionAlgorithm){
    Election le=null;
            
    //TODO: use a factory rather than a switch
    switch (electionAlgorithm) {
    case 0:
        le = new LeaderElection(this);
        break;
    case 1:
        le = new AuthFastLeaderElection(this);
        break;
    case 2:
        le = new AuthFastLeaderElection(this, true);
        break;
    case 3:
        //默认用该选举算法
        //构造QuorumCnxManager组件用于管理server之间的tcp连接
        qcm = new QuorumCnxManager(this);
        QuorumCnxManager.Listener listener = qcm.listener;
        if(listener != null){
            //启动Listener线程，用于监听其他server客户端的连接
            listener.start();
            //构建leader选举算法
            le = new FastLeaderElection(this, qcm);
        } else {
            LOG.error("Null listener when initializing cnx manager");
        }
        break;
    default:
        assert false;
    }
    return le;
}
```

FastLeaderElection构造的时候会初始化Messenger组件来启动读、写IO线程。和用于发送和接受选票数据的队列

```java
public FastLeaderElection(QuorumPeer self, QuorumCnxManager manager){
    this.stop = false;
    this.manager = manager;
    starter(self, manager);
}
```

QuorumCnxManager组件进行了很好的封装，专门用于处理节点间的通信

```java
private void starter(QuorumPeer self, QuorumCnxManager manager) {
    this.self = self;
    proposedLeader = -1;
    proposedZxid = -1;

    //初始化无界队列，用于存放发送与接收选票
    sendqueue = new LinkedBlockingQueue<ToSend>();
    recvqueue = new LinkedBlockingQueue<Notification>();
    //初始化Messenger组件，用不同的线程来处理网络传输发送与接收数据逻辑
    this.messenger = new Messenger(manager);
}
```

构造Messenger组件用于启动WorkerSender线程来发送网络数据和WorkerReceiver线程来接收网络数据

```java
Messenger(QuorumCnxManager manager) {

    this.ws = new WorkerSender(manager);

    Thread t = new Thread(this.ws,
            "WorkerSender[myid=" + self.getId() + "]");
    t.setDaemon(true);
    t.start();

    this.wr = new WorkerReceiver(manager);

    t = new Thread(this.wr,
            "WorkerReceiver[myid=" + self.getId() + "]");
    t.setDaemon(true);
    t.start();
}
```

## WorkerReceiver接收选票数据线程

WorkerReceiver线程执行核心流程：

1. 不停地从QuorumCnxManager网络组件的接收数据队列中获取选票
2. 如果当前节点状态是LOOKING，则将选票信息放入接收选票队列recvqueue中，后续选票逻辑从该队列获取并处理
3. 如果当前节点和发送过来选票的节点状态都是LOOKING，并且选票轮次小于当前节点，则表示选票无效，同时将当前节点选票发送过去
4. 当前节点状态不再是LOOKING，也就是知道了LEAD节点信息，但是发送过来选票的节点状态是LOOKING，则将LEAD选票信息发送过去

```java
class WorkerReceiver implements Runnable {
    volatile boolean stop;
    QuorumCnxManager manager;

    WorkerReceiver(QuorumCnxManager manager) {
        this.stop = false;
        this.manager = manager;
    }

    public void run() {

        Message response;
        while (!stop) {
            // Sleeps on receive
            try{
                //从recvQueue队列阻塞获取选票数据
                response = manager.pollRecvQueue(3000, TimeUnit.MILLISECONDS);
                if(response == null) continue;

                /*
                 * If it is from an observer, respond right away.
                 * Note that the following predicate assumes that
                 * if a server is not a follower, then it must be
                 * an observer. If we ever have any other type of
                 * learner in the future, we'll have to change the
                 * way we check for observers.
                 */
                //如果本地不包含响应中的myid，则表示属于observer节点
                if(!self.getVotingView().containsKey(response.sid)){
                    Vote current = self.getCurrentVote();
                    ToSend notmsg = new ToSend(ToSend.mType.notification,
                            current.getId(),
                            current.getZxid(),
                            logicalclock,
                            self.getPeerState(),
                            response.sid,
                            current.getPeerEpoch());

                    sendqueue.offer(notmsg);
                } else {
                    // Receive new message
                    if (LOG.isDebugEnabled()) {
                        LOG.debug("Receive new notification message. My id = "
                                + self.getId());
                    }

                    /*
                     * We check for 28 bytes for backward compatibility
                     */
                    if (response.buffer.capacity() < 28) {
                        LOG.error("Got a short response: "
                                + response.buffer.capacity());
                        continue;
                    }
                    boolean backCompatibility = (response.buffer.capacity() == 28);
                    response.buffer.clear();

                    // State of peer that sent this message
                    QuorumPeer.ServerState ackstate = QuorumPeer.ServerState.LOOKING;
                    switch (response.buffer.getInt()) {
                    case 0:
                        ackstate = QuorumPeer.ServerState.LOOKING;
                        break;
                    case 1:
                        ackstate = QuorumPeer.ServerState.FOLLOWING;
                        break;
                    case 2:
                        ackstate = QuorumPeer.ServerState.LEADING;
                        break;
                    case 3:
                        ackstate = QuorumPeer.ServerState.OBSERVING;
                        break;
                    }

                    // Instantiate Notification and set its attributes
                    //将接收到的消息进行解析
                    Notification n = new Notification();
                    n.leader = response.buffer.getLong();
                    n.zxid = response.buffer.getLong();
                    n.electionEpoch = response.buffer.getLong();
                    n.state = ackstate;
                    n.sid = response.sid;
                    if(!backCompatibility){
                        n.peerEpoch = response.buffer.getLong();
                    } else {
                        if(LOG.isInfoEnabled()){
                            LOG.info("Backward compatibility mode, server id=" + n.sid);
                        }
                        //zxid的前32位就是epoch版本号
                        n.peerEpoch = ZxidUtils.getEpochFromZxid(n.zxid);
                    }

                    /*
                     * Print notification info
                     */
                    if(LOG.isInfoEnabled()){
                        printNotification(n);
                    }

                    /*
                     * If this server is looking, then send proposed leader
                     */

                    if(self.getPeerState() == QuorumPeer.ServerState.LOOKING){
                        //如果当前server的状态是LOOKING，则将接收到的选票放入到接收选票队列中
                        recvqueue.offer(n);

                        /*
                         * Send a notification back if the peer that sent this
                         * message is also looking and its logical clock is
                         * lagging behind.
                         */
                        //如果响应的数据是LOOKING状态，并且版本号小于当前节点版本号，说明该节点的选票无效
                        //则将当前节点选票发送过去
                        if((ackstate == QuorumPeer.ServerState.LOOKING)
                                && (n.electionEpoch < logicalclock)){
                            Vote v = getVote();
                            ToSend notmsg = new ToSend(ToSend.mType.notification,
                                    v.getId(),
                                    v.getZxid(),
                                    logicalclock,
                                    self.getPeerState(),
                                    response.sid,
                                    v.getPeerEpoch());
                            sendqueue.offer(notmsg);
                        }
                    } else {
                        /*
                         * If this server is not looking, but the one that sent the ack
                         * is looking, then send back what it believes to be the leader.
                         */
                        //如果当前server已经知道投票结果，也就是leader信息，但是接收到其他server的消息状态是LOOKING，则将Leader信息发送回去
                        Vote current = self.getCurrentVote();
                        if(ackstate == QuorumPeer.ServerState.LOOKING){
                            if(LOG.isDebugEnabled()){
                                LOG.debug("Sending new notification. My id =  " +
                                        self.getId() + " recipient=" +
                                        response.sid + " zxid=0x" +
                                        Long.toHexString(current.getZxid()) +
                                        " leader=" + current.getId());
                            }
                            ToSend notmsg = new ToSend(
                                    ToSend.mType.notification,
                                    current.getId(),
                                    current.getZxid(),
                                    logicalclock,
                                    self.getPeerState(),
                                    response.sid,
                                    current.getPeerEpoch());
                            sendqueue.offer(notmsg);
                        }
                    }
                }
            } catch (InterruptedException e) {
                System.out.println("Interrupted Exception while waiting for new message" +
                        e.toString());
            }
        }
        LOG.info("WorkerReceiver is down");
    }
}
```

## WorkerSender发送选票线程

选票发送的逻辑比较简单，从待发送队列sendqueue获取到数据后调用QuorumCnxManager网络组件发送出去

WorkerReceiver线程执行核心流程：

1. 从sendqueue待发送选票队列中获取选票数据
2. 将选票数据序列化为自定义的字节数组，调用QuorumCnxManager组件发送给指定的节点

```java
class WorkerSender implements Runnable {
    volatile boolean stop;
    QuorumCnxManager manager;

    WorkerSender(QuorumCnxManager manager){
        this.stop = false;
        this.manager = manager;
    }

    public void run() {
        while (!stop) {
            try {
                //从sendqueue队列阻塞获取需要发送的选票数据
                ToSend m = sendqueue.poll(3000, TimeUnit.MILLISECONDS);
                if(m == null) continue;

                //从sendqueue队列获取需要发送的数据来处理
                process(m);
            } catch (InterruptedException e) {
                break;
            }
        }
        LOG.info("WorkerSender is down");
    }

    /**
     * Called by run() once there is a new message to send.
     *
     * @param m     message to send
     */
    private void process(ToSend m) {
        byte requestBytes[] = new byte[36];
        ByteBuffer requestBuffer = ByteBuffer.wrap(requestBytes);

        /*
         * Building notification packet to send
         */

		//自定义选票数据网络传输协议
        requestBuffer.clear();
        requestBuffer.putInt(m.state.ordinal());
        requestBuffer.putLong(m.leader);
        requestBuffer.putLong(m.zxid);
        requestBuffer.putLong(m.electionEpoch);
        requestBuffer.putLong(m.peerEpoch);

        //最终调用的是QuorumCnxManager进行网络传输发送出去
        manager.toSend(m.sid, requestBuffer);

    }
}
```

## QuorumPeer线程发起投票并等待结果

核心流程：

1. 启动QuorumPeer线程进行投票，直到有leader选举出来
2. 根据投票结果执行leader或者follower的功能逻辑

在投票算法初始化完成后，会启动QuorumPeer线程来发起投票

```java
@Override
public synchronized void start() {
    //从磁盘加载数据文件到内存
    loadDataBase();

    //启动服务端NIOServerCnxnFactory线程
    cnxnFactory.start();

    //初始化 leader 选举算法
    startLeaderElection();

    //启动QuorumPeer线程
    super.start();
}
```

QuorumPeer线程运行方法

```java
@Override
public void run() {
    setName("QuorumPeer" + "[myid=" + getId() + "]" +
            cnxnFactory.getLocalAddress());

  	...
    try {
        /*
         * Main loop
         */
        //在默认情况下当前server为LOOKING，直到leader被选出，才会break，后续根据选举出的状态执行leading或者following的逻辑
        while (running) {
            switch (getPeerState()) {
                //默认状态LOOKING
            case LOOKING:
                LOG.info("LOOKING");

                if (Boolean.getBoolean("readonlymode.enabled")) {
                    LOG.info("Attempting to start ReadOnlyZooKeeperServer");

                    // Create read-only server but don't start it immediately
                    final ReadOnlyZooKeeperServer roZk = new ReadOnlyZooKeeperServer(
                            logFactory, this,
                            new ZooKeeperServer.BasicDataTreeBuilder(),
                            this.zkDb);

                    // Instead of starting roZk immediately, wait some grace
                    // period before we decide we're partitioned.
                    //
                    // Thread is used here because otherwise it would require
                    // changes in each of election strategy classes which is
                    // unnecessary code coupling.
                    Thread roZkMgr = new Thread() {
                        public void run() {
                            try {
                                // lower-bound grace period to 2 secs
                                sleep(Math.max(2000, tickTime));
                                if (ServerState.LOOKING.equals(getPeerState())) {
                                    roZk.startup();
                                }
                            } catch (InterruptedException e) {
                                LOG.info("Interrupted while attempting to start ReadOnlyZooKeeperServer, not started");
                            } catch (Exception e) {
                                LOG.error("FAILED to start ReadOnlyZooKeeperServer", e);
                            }
                        }
                    };
                    try {
                        roZkMgr.start();
                        setCurrentVote(makeLEStrategy().lookForLeader());
                    } catch (Exception e) {
                        LOG.warn("Unexpected exception",e);
                        setPeerState(ServerState.LOOKING);
                    } finally {
                        // If the thread is in the the grace period, interrupt
                        // to come out of waiting.
                        roZkMgr.interrupt();
                        roZk.shutdown();
                    }
                } else {
                    try {
                        //调用之前初始化的FastLeaderElection算法进行投票
                        //lookForLeader一定会选出 leader，这里会被卡住
                        //方法返回后，设置选票，在下一次循环执行作为各个状态的事情
                        setCurrentVote(makeLEStrategy().lookForLeader());
                    } catch (Exception e) {
                        LOG.warn("Unexpected exception", e);
                        setPeerState(ServerState.LOOKING);
                    }
                }
                break;
            case OBSERVING:
                try {
                    LOG.info("OBSERVING");
                    setObserver(makeObserver(logFactory));
                    observer.observeLeader();
                } catch (Exception e) {
                    LOG.warn("Unexpected exception",e );                        
                } finally {
                    observer.shutdown();
                    setObserver(null);
                    setPeerState(ServerState.LOOKING);
                }
                break;
            case FOLLOWING:
                try {
                    LOG.info("FOLLOWING");
                    setFollower(makeFollower(logFactory));
                    follower.followLeader();
                } catch (Exception e) {
                    LOG.warn("Unexpected exception",e);
                } finally {
                    follower.shutdown();
                    setFollower(null);
                    setPeerState(ServerState.LOOKING);
                }
                break;
            case LEADING:
                //如果投票结束，当前server是leader则执行对应逻辑
                LOG.info("LEADING");
                try {
                    //初始化Leader对象
                    setLeader(makeLeader(logFactory));
                    //调用其lead方法处理lead的逻辑
                    leader.lead();
                    setLeader(null);
                } catch (Exception e) {
                    LOG.warn("Unexpected exception",e);
                } finally {
                    if (leader != null) {
                        leader.shutdown("Forcing shutdown");
                        setLeader(null);
                    }
                    setPeerState(ServerState.LOOKING);
                }
                break;
            }
        }
    } finally {
        LOG.warn("QuorumPeer main thread exited");
        try {
            MBeanRegistry.getInstance().unregisterAll();
        } catch (Exception e) {
            LOG.warn("Failed to unregister with JMX", e);
        }
        jmxQuorumBean = null;
        jmxLocalPeerBean = null;
    }
}
```

## lookForLeader方法开启一轮新的投票

每个节点选票变更后再次广播出去发送给所有节点；选票PK规则是比较版本号、比较zxid选更大、比较myid选更大；投票箱存放所有节点的有效选票，超过大多数投同一个节点则可以确定leader

核心流程：

1. 初始化recvset投票结果集，保存接收到的每个sid的投票信息，最后根据它进行归票
2. 每一轮的投票都会将logicalclock轮次递增，只有leader需要重新选举才会可能不一致
3. 开始每个节点都初始化自己为leader选票，并发送给所有的其他节点，包括自己
4. 开始投票，直到选出leader为止（状态不为LOOKING)
5. 从接收选票队列recvqueue中获取选票
6. 如果外部选票轮次大于当前节点轮次，则覆盖为当前节点轮次信息，并清空recvset投票结果集。随后选票pk后更新为自己的选票，并发送出去
7. 如果接收选票轮次小于当前节点轮次，直接忽略选票
8. 如果接收到的选票版本号相同，表示选票有效，pk后如果有必要则更新为自己的选票，并发送出去
9. 最后将有效选票放入recvset投票结果集
10. 根据recvset投票结果集进行归票操作，如果有大多数选票是同一个节点，则表示投票结束，更新节点状态并返回选票信息

```java
/**
 * Starts a new round of leader election. Whenever our QuorumPeer
 * changes its state to LOOKING, this method is invoked, and it
 * sends notifications to all other peers.
 * zk 集群中的每一台主机，在不同的阶段会处于不同的状态。每一台主机具有四种状态。
 *
 * LOOKING：选举状态
 * FOLLOWING：Follower 的正常工作状态
 * OBSERVING：Observer 的正常工作状态
 * LEADING：Leader 的正常工作状态
 *
 * 启动新一轮的投票，每当当前server的状态变为LOOKING时，该方法就会别调用，并会发送消息给所有server
 */
public Vote lookForLeader() throws InterruptedException {
    ...
    if (self.start_fle == 0) {
       self.start_fle = System.currentTimeMillis();
    }
    try {
        // 用于存放来自于外部的选票，一个entry代表一次投票
        // key为投票者的serverid，value为选票
        // 该集合相当于投票箱
        HashMap<Long, Vote> recvset = new HashMap<Long, Vote>();

        // outofelection，out of election，退出选举
        // 其中存放的是非法选票，即投票者的状态不是looking
        HashMap<Long, Vote> outofelection = new HashMap<Long, Vote>();

        int notTimeout = finalizeWait;

        synchronized(this){
            //每次选举默认都是相同的版本号，除非重启后会不同
            logicalclock++;
            //封装投票信息由myid、zxid、epoch组成。开始都会将自己作为 leader 选票
            updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch());
        }

        LOG.info("New election. My id =  " + self.getId() +
                ", proposed zxid=0x" + Long.toHexString(proposedZxid));
        //将自己的投票发送给所有server(包括自己)
        sendNotifications();

        /*
         * Loop in which we exchange notifications until we find a leader
         */

        //循环交换投票直至选出Leader
        while ((self.getPeerState() == ServerState.LOOKING) &&
                (!stop)){
            /*
             * Remove next notification from queue, times out after 2 times
             * the termination time
             */
            //有专门线程去处理接收其他Server发来的通知
            //并将接收到的信息解析封装成Notification 放入recvqueue队列
            Notification n = recvqueue.poll(notTimeout,
                    TimeUnit.MILLISECONDS);

            /*
             * Sends more notifications if haven't received enough.
             * Otherwise processes new notification.
             */
            //每台服务器会不断地从recvqueue队列中获取外部选票。如果服务器发现无法获取到任何外部投票，
            //那么就会立即确认自己是否和集群中其他服务器保持着有效的连接，如果没有连接，则马上建立连接，如果已经建立了连接，则再次发送自己当前的内部投票
            if(n == null){
                //简单来说该方法就是判断是否和集群失联，返回false表示失联
                if(manager.haveDelivered()){
                    //重新发送选票，为了重新再接收
                    sendNotifications();
                } else {
                    //如果manager.haveDelivered()返回false，表明当前Server和集群已经失联，所以重新连接zk集群中的每一个server
                    //为什么重连了，不需要重新发送通知了呢？
                    //因为我失联了，但是发送队列中的消息是还再的，重新连接后会重新继续发送，而且其他Server在recvqueue.poll为null的时候，如果没有和集群失联，也会重新sendNotifications，所以这里是不需要的。
                    manager.connectAll();
                }

                /*
                 * Exponential backoff
                 */
                //重新发送通知或者重连集群后，将通知超时时间扩大两倍，如果超过最大通知时间，将超时时间置为最大时间
                int tmpTimeOut = notTimeout*2;
                notTimeout = (tmpTimeOut < maxNotificationInterval?
                        tmpTimeOut : maxNotificationInterval);
                LOG.info("Notification time out: " + notTimeout);
            }
            //判断是否具有选举权和被选举权
            else if(self.getVotingView().containsKey(n.sid)) {
                /*
                 * Only proceed if the vote comes from a replica in the
                 * voting view.
                 */
                switch (n.state) {
                case LOOKING:

                    //外部投票的选举轮次大于内部投票。若服务器自身的选举轮次落后于该外部投票对应服务器的选举轮次，
                    // 那么就会立即更新自己的选举轮次(logicalclock)，并且清空所有已经收到的投票，然后使用初始化的投票来进行PK以确定是否变更内部投票。最终再将内部投票发送出去
                    // If notification > current, replace and send messages out
                    if (n.electionEpoch > logicalclock) {
                        //更新当前 server 所在的选举的版本号
                        logicalclock = n.electionEpoch;
                        //清空投票箱
                        recvset.clear();

                        //判断当前 server 和收到的 n 谁更适合做 leader，随后需要更新当前 server 的投票信息并广播出去
                        if(totalOrderPredicate(n.leader, n.zxid, n.peerEpoch,
                                getInitId(), getInitLastLoggedZxid(), getPeerEpoch())) {
                            //如果n满足成为 leader则更新 当前 server 的选票信息
                            updateProposal(n.leader, n.zxid, n.peerEpoch);
                        } else {
                            //否则也更新当前 server 的选票信息
                            updateProposal(getInitId(),
                                    getInitLastLoggedZxid(),
                                    getPeerEpoch());
                        }
                        //将决策后的选票再次广播出去
                        sendNotifications();
                    } else if (n.electionEpoch < logicalclock) {
                        //外部投票的选举轮次小于内部投票。若服务器接收的外选票的选举轮次落后于自身的选举轮次，那么Zookeeper就会直接忽略该外部投票，不做任何处理
                        if(LOG.isDebugEnabled()){
                            LOG.debug("Notification election epoch is smaller than logicalclock. n.electionEpoch = 0x"
                                    + Long.toHexString(n.electionEpoch)
                                    + ", logicalclock=0x" + Long.toHexString(logicalclock));
                        }
                        //跳出 switch 重新进入循环从 recvqueue 取下一个通知继续处理
                        break;
                        //否则版本号相同，则判断谁更加适合成为 Leader
                    } else if (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch,
                            proposedLeader, proposedZxid, proposedEpoch)) {
                        //如果满足投票规则，则更新当前 server 的选票
                        updateProposal(n.leader, n.zxid, n.peerEpoch);
                        //并且再次将选票发送出去
                        sendNotifications();
                    }

                    if(LOG.isDebugEnabled()){
                        LOG.debug("Adding vote: from=" + n.sid +
                                ", proposed leader=" + n.leader +
                                ", proposed zxid=0x" + Long.toHexString(n.zxid) +
                                ", proposed election epoch=0x" + Long.toHexString(n.electionEpoch));
                    }


                    //特殊情况：当前服务器收到外来通知发现外来通知推荐的leader更适合以后，会更新自己的推荐信息并再次广播出去，
                    //这个时候recvqueue除了第一次广播推荐自己收到的回复外，还会收到新一轮广播的回复，对于其他Server而言有可能会回复两次通知，
                    //但对于本地Server是没有影响的，因为投票箱recvset是一个Map，key是发送消息的服务器的ServerId，每个Server只会记录一个投票，新的会覆盖旧的


                    //执行到这里，说明外来 server 的版本号大于等于当前 server，代表当前 server 接收到的投票有效，放入投票箱
                    recvset.put(n.sid, new Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch));


                    //判断本轮选举是否可以结束了。如果不可用结束，执行后续的 break，进入下一轮循环从recvqueue获取选票

                    //尝试通过现在已经收到的信息，判断是否已经足够确认最终的leader了，通过方法termPredicate() ，
                    //判断标准很简单：是否已经有超过半数的机器所推举的leader为当前自己所推举的leader.
                    //如果是，保险起见，最多再等待finalizeWait（默认200ms）的时间进行最后的确认，
                    //如果发现有了更新的leader信息，则把这个Notification重新放回recvqueue,显然，选举将继续进行。
                    //否则，选举结束，根据选举的leader是否是自己，设置自己的状态为LEADING或者OBSERVING或者FOLLOWING。

                    if (termPredicate(recvset,
                            new Vote(proposedLeader, proposedZxid,
                                    logicalclock, proposedEpoch))) {

                        // Verify if there is any change in the proposed leader
                        //已经过半了，但是recvqueue里面的通知还没处理完，还有可能有更适合的Leader通知
                        //该循环有两个出口：
                        //break：从该出口跳出，说明n的值不为null，说明在剩余的通知中找到了更适合做leader的通知
                        //while()条件：从该出口跳出，说明n的值为null，说明在剩余的通知中没有比当前server所推荐的leader更适合的了
                        while((n = recvqueue.poll(finalizeWait,
                                TimeUnit.MILLISECONDS)) != null){
                            if(totalOrderPredicate(n.leader, n.zxid, n.peerEpoch,
                                    proposedLeader, proposedZxid, proposedEpoch)){
                                //将更适合的n重新放回到recvqueue，以便对其进行重新投票
                                recvqueue.put(n);
                                break;
                            }
                        }

                        /*
                         * This predicate is true once we don't read any new
                         * relevant message from the reception queue
                         */
                        // 修改当前server的状态，非leader即following
                        // 如果推荐的Leader就是我自己，修改我当前状态为LEADING
                        // 如果不是我自己，判断自己是否是参与者，如果是则状态置为FOLLOWING，否则是OBSERVING
                        if (n == null) {
                            //修改当前server的状态，非leader即following
                            self.setPeerState((proposedLeader == self.getId()) ?
                                    ServerState.LEADING: learningState());

                            //形成最终选票
                            Vote endVote = new Vote(proposedLeader,
                                    proposedZxid, proposedEpoch);
                            //清空 recvqueue 队列
                            leaveInstance(endVote);
                            //返回最终选票，选举方法就结束了
                            return endVote;
                        }
                    }
                    break;
                case OBSERVING:
                    //OBSERVING不参与选票
                    LOG.debug("Notification from observer: " + n.sid);
                    break;
                case FOLLOWING:
                case LEADING:
                    /*
                     * Consider all notifications from the same epoch
                     * together.
                     */
                    //如果对方的logicalclock等于本地的logicalclock，把对方的投票信息保存到本地投票统计箱recvset中，
                    //判断对方的投票信息是否在recvset中占大多数并且确认自己确实为leader，如果是则确定角色，结束选举
                    if(n.electionEpoch == logicalclock){
                      recvset.put(n.sid, new Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch));
                        if(termPredicate(recvset, new Vote(n.leader,
                                        n.zxid, n.electionEpoch, n.peerEpoch, n.state))
                                        && checkLeader(outofelection, n.leader, n.electionEpoch)) {
                            //选票选出来后更新当前 server 的状态
                            self.setPeerState((n.leader == self.getId()) ?
                                    ServerState.LEADING: learningState());

                            Vote endVote = new Vote(n.leader, n.zxid, n.peerEpoch);
                            //清空队列中消息
                            leaveInstance(endVote);
                            return endVote;
                        }
                    }

                    /**
                     * Before joining an established ensemble, verify that
                     * a majority are following the same leader.
                     */
                    //将对方的投票信息放入本地统计不参与投票信息箱outofelection中，判断对方的投票信息是否在outofelection中占大多数并且确认自己确实为leader，
                    //如果是则更新logicalclock，并确定角色，结束选举，否则进入下一轮选举
                    outofelection.put(n.sid, new Vote(n.leader, n.zxid,
                            n.electionEpoch, n.peerEpoch, n.state));
                    if (termPredicate(outofelection, new Vote(n.leader,
                            n.zxid, n.electionEpoch, n.peerEpoch, n.state))
                            && checkLeader(outofelection, n.leader, n.electionEpoch)) {
                        synchronized(this){
                            logicalclock = n.electionEpoch;
                            self.setPeerState((n.leader == self.getId()) ?
                                    ServerState.LEADING: learningState());
                        }
                        Vote endVote = new Vote(n.leader, n.zxid, n.peerEpoch);
                        leaveInstance(endVote);
                        return endVote;
                    }
                    break;
                default:
                    LOG.warn("Notification state unrecoginized: " + n.state
                          + " (n.state), " + n.sid + " (n.sid)");
                    break;
                }
            } else {
                LOG.warn("Ignoring notification from non-cluster member " + n.sid);
            }
        }
        return null;
    } finally {
        try {
            if(self.jmxLeaderElectionBean != null){
                MBeanRegistry.getInstance().unregister(
                        self.jmxLeaderElectionBean);
            }
        } catch (Exception e) {
            LOG.warn("Failed to unregister with JMX", e);
        }
        self.jmxLeaderElectionBean = null;
    }
}
```

发送选票给所有节点，也就是将选票发送到选票发送队列sendqueue中，后续有WorkerSender发送线程专门来发送选票

```java
/**
 * Send notifications to all peers upon a change in our vote
 */
private void sendNotifications() {
    //所有具有选举权和被选举权的Server
    for (QuorumServer server : self.getVotingView().values()) {
        long sid = server.id;

        ToSend notmsg = new ToSend(ToSend.mType.notification,//消息类型
                proposedLeader,//推荐的Leader的ServerId（myid）
                proposedZxid,//推荐的Leader的zxid
                logicalclock,//此次选举的逻辑时钟
                QuorumPeer.ServerState.LOOKING,//当前Server的状态
                sid,// 接受者的server id
                proposedEpoch);//推荐的Leader的epoch
        if(LOG.isDebugEnabled()){
            LOG.debug("Sending Notification: " + proposedLeader + " (n.leader), 0x"  +
                  Long.toHexString(proposedZxid) + " (n.zxid), 0x" + Long.toHexString(logicalclock)  +
                  " (n.round), " + sid + " (recipient), " + self.getId() +
                  " (myid), 0x" + Long.toHexString(proposedEpoch) + " (n.peerEpoch)");
        }
        //将推荐的Leader信息封装成ToSend对象放入发送队列，后续有其他线程专门来处理
        sendqueue.offer(notmsg);
    }
}
```

选取更优选票的算法

```java
/**
 * Check if a pair (server id, zxid) succeeds our
 * current vote.
 *
 * @param id    Server identifier
 * @param zxid  Last zxid observed by the issuer of this vote
 *
 * 选举的规则：
 * 1.版本号更高
 * 2.版本号相同，zxid 更大
 * 3.版本号相同，zxid 相同，myid 更大
 */
protected boolean totalOrderPredicate(long newId, long newZxid, long newEpoch, long curId, long curZxid, long curEpoch) {
    LOG.debug("id: " + newId + ", proposed id: " + curId + ", zxid: 0x" +
            Long.toHexString(newZxid) + ", proposed zxid: 0x" + Long.toHexString(curZxid));
    if(self.getQuorumVerifier().getWeight(newId) == 0){
        return false;
    }
    
    /*
     * We return true if one of the following three cases hold:
     * 1- New epoch is higher
     * 2- New epoch is the same as current epoch, but new zxid is higher
     * 3- New epoch is the same as current epoch, new zxid is the same
     *  as current zxid, but server id is higher.
     */
    
    return ((newEpoch > curEpoch) || 
            ((newEpoch == curEpoch) &&
            ((newZxid > curZxid) || ((newZxid == curZxid) && (newId > curId)))));
}
```

判断是否可以结束选票，也就是归票的逻辑

```java
/**
 * Termination predicate. Given a set of votes, determines if
 * have sufficient to declare the end of the election round.
 *
 *  @param votes    Set of votes
 *  @param l        Identifier of the vote received last
 *  @param zxid     zxid of the the vote received last
 */
private boolean termPredicate(
        HashMap<Long, Vote> votes,
        Vote vote) {

    HashSet<Long> set = new HashSet<Long>();

    /*
     * First make the views consistent. Sometimes peers will have
     * different zxids for a server depending on timing.
     */
    //遍历票箱：从票箱中查找与选票vote相同的选票
    for (Map.Entry<Long,Vote> entry : votes.entrySet()) {
        if (vote.equals(entry.getValue())){
            set.add(entry.getKey());
        }
    }

    //如果有超过半数选票的则结束投票
    return self.getQuorumVerifier().containsQuorum(set);
}
```

# 流程图

![Leader选举流程](D:\user\文档\cl\doc\zk\2.leader选举算法.assets\Leader选举流程.jpg)

# 亮点分析

管理选票组件FastLeaderElection与节点间网络通信组件QuorumCnxManager进行了封装，功能职责更加清晰，通过队列进行交互

