# sessionId标识创建方式

通过一个long类型变量从0开始，并发安全的递增作为sessionId唯一标识

```java
long createSession(ServerCnxn cnxn, byte passwd[], int timeout) {
    //生成sessionId
    long sessionId = sessionTracker.createSession(timeout);
    Random r = new Random(sessionId ^ superSecret);
    r.nextBytes(passwd);
    ByteBuffer to = ByteBuffer.allocate(4);
    to.putInt(timeout);
    cnxn.setSessionId(sessionId);
    //向客户端发送createSession请求
    submitRequest(cnxn, sessionId, OpCode.createSession, 0, to, null);
    return sessionId;
}
```

nextSessionId初始是0，该方法synchronized修饰避免并发调用，

```java
synchronized public long createSession(int sessionTimeout) {
    //将session添加到session管理器中
    addSession(nextSessionId, sessionTimeout);
    //返回唯一sessionId
    return nextSessionId++;
}
```

# 服务端session分桶管理

session管理的方法都加上了synchronized同步修饰，避免了并发修改的问题，所以类的成员变量不需要考虑并发问题

```java
public class SessionTrackerImpl extends Thread implements SessionTracker {
    private static final Logger LOG = LoggerFactory.getLogger(SessionTrackerImpl.class);

    //sessionId对应session
    HashMap<Long, SessionImpl> sessionsById = new HashMap<Long, SessionImpl>();

    //每个过期时间（桶）下的所有session集合
    HashMap<Long, SessionSet> sessionSets = new HashMap<Long, SessionSet>();

    //sessionId对应过期时间
    ConcurrentHashMap<Long, Integer> sessionsWithTimeout;
    long nextSessionId = 0;
    long nextExpirationTime;

    int expirationInterval;
     
    ...
    /**
     * 延长对应的session的超时的时间
     * @param sessionId
     * @param timeout
     * @return
     */
    synchronized public boolean touchSession(long sessionId, int timeout) {
        if (LOG.isTraceEnabled()) {
            ZooTrace.logTraceMessage(LOG,
                                     ZooTrace.CLIENT_PING_TRACE_MASK,
                                     "SessionTrackerImpl --- Touch session: 0x"
                    + Long.toHexString(sessionId) + " with timeout " + timeout);
        }
        SessionImpl s = sessionsById.get(sessionId);
        // Return false, if the session doesn't exists or marked as closing
        //对应session已经被标识为关闭
        if (s == null || s.isClosing()) {
            return false;
        }
		//计算刚好大于超时时间的整倍数expirationInterval
        long expireTime = roundToInterval(System.currentTimeMillis() + timeout);
        //未过期不用处理
        if (s.tickTime >= expireTime) {
            // Nothing needs to be done
            return true;
        }
        //如果已过期，则从sessionSets移除
        SessionSet set = sessionSets.get(s.tickTime);
        if (set != null) {
            //移除原来位置的session
            set.sessions.remove(s);
        }
        //保存至sessionSets中
        s.tickTime = expireTime;
        set = sessionSets.get(s.tickTime);
        if (set == null) {
            //加入到新的session
            set = new SessionSet();
            sessionSets.put(expireTime, set);
        }
        set.sessions.add(s);
        return true;
    }
    ...
}
```

# 过期session策略

定时任务每隔一段时间（桶的间隔时间），将需要过期的桶所包含的多个session都过期掉

```java
/**
 * 会话失效策略
 */
@Override
synchronized public void run() {
    try {
        while (running) {
            currentTime = System.currentTimeMillis();
            if (nextExpirationTime > currentTime) {
                //等待时间到nextExpirationTime
                this.wait(nextExpirationTime - currentTime);
                continue;
            }
            SessionSet set;
            //获取超时时间是nextExpirationTime的对应的sessionId
            set = sessionSets.remove(nextExpirationTime);
            if (set != null) {
                for (SessionImpl s : set.sessions) {
                    //将nextExpirationTime对应的session关闭
                    //SessionImpl标识位关闭
                    setSessionClosing(s.sessionId);
                    //进行closeSession的操作
                    //给客户端发送closeSession请求关闭session连接
                    expirer.expire(s);
                }
            }
            //更新下一次的对应的check的时间
            nextExpirationTime += expirationInterval;
        }
    } catch (InterruptedException e) {
        LOG.error("Unexpected interruption", e);
    }
    LOG.info("SessionTrackerImpl exited loop!");
}
```

过期的session的客户端连接将会被关闭

```java
public void expire(Session session) {
    long sessionId = session.getSessionId();
    LOG.info("Expiring session 0x" + Long.toHexString(sessionId)
             + ", timeout of " + session.getTimeout() + "ms exceeded");
    close(sessionId);
}
```

```java
private void close(long sessionId) {
    submitRequest(null, sessionId, OpCode.closeSession, 0, null, null);
}
```

# 流程图

![img](D:\user\文档\cl\doc\zk\6.session管理.assets\20210922173212458.png)



